"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dorita980_1 = __importDefault(require("dorita980"));
/**
 * How long to wait to connect to Roomba.
 */
const CONNECT_TIMEOUT_MILLIS = 60000;
/**
 * When actively watching Roomba's status, how often to query Roomba and update HomeKit.
 */
const WATCH_INTERVAL_MILLIS = 5000;
/**
 * After starting to actively watch Roomba's status, how long should we watch for after
 * the last status enquiry from HomeKit? This lets us stop checking on Roomba when no
 * one is interested.
 */
const WATCH_IDLE_TIMEOUT_MILLIS = 600000;
/**
 * How often to query Roomba and update HomeKit when not actively watching Roomba's status.
 */
const LONG_WATCH_INTERVAL_MILLIS = 60000;
/**
 * How long will we wait for the Roomba to send status before giving up?
 */
const MAX_WAIT_FOR_STATUS_MILLIS = 60000;
/**
 * How old a cached status can be before we ignore it.
 */
const MAX_CACHED_STATUS_AGE_MILLIS = LONG_WATCH_INTERVAL_MILLIS + MAX_WAIT_FOR_STATUS_MILLIS * 5;
/**
 * Coalesce refreshState requests into one when they're less than this many millis apart.
 */
const REFRESH_STATE_COALESCE_MILLIS = 10000;
const EMPTY_STATUS = {
    timestamp: 0,
};
const NO_VALUE = new Error("No value");
async function delay(duration) {
    return new Promise((resolve) => {
        setTimeout(resolve, duration);
    });
}
class RoombaAccessory {
    constructor(log, config, api) {
        /**
         * The last known state from Roomba, if any.
         */
        this.cachedStatus = EMPTY_STATUS;
        this.lastUpdatedStatus = EMPTY_STATUS;
        this.lastRefreshState = 0;
        /**
         * How many requests are currently using the connected Roomba instance.
         */
        this._currentlyConnectedRoombaRequests = 0;
        this.runningStatus = (status) => status.running === undefined
            ? undefined
            : status.running
                ? 1
                : 0;
        this.chargingStatus = (status) => status.charging === undefined
            ? undefined
            : status.charging
                ? this.api.hap.Characteristic.ChargingState.CHARGING
                : this.api.hap.Characteristic.ChargingState.NOT_CHARGING;
        this.dockingStatus = (status) => status.docking === undefined
            ? undefined
            : status.docking
                ? this.api.hap.Characteristic.ContactSensorState.CONTACT_NOT_DETECTED
                : this.api.hap.Characteristic.ContactSensorState.CONTACT_DETECTED;
        this.dockedStatus = (status) => status.charging === undefined
            ? undefined
            : status.charging
                ? this.api.hap.Characteristic.ContactSensorState.CONTACT_DETECTED
                : this.api.hap.Characteristic.ContactSensorState.CONTACT_NOT_DETECTED;
        this.batteryLevelStatus = (status) => status.batteryLevel === undefined
            ? undefined
            : status.batteryLevel;
        this.binStatus = (status) => status.binFull === undefined
            ? undefined
            : status.binFull
                ? this.api.hap.Characteristic.FilterChangeIndication.CHANGE_FILTER
                : this.api.hap.Characteristic.FilterChangeIndication.FILTER_OK;
        this.batteryStatus = (status) => status.batteryLevel === undefined
            ? undefined
            : status.batteryLevel <= 20
                ? this.api.hap.Characteristic.StatusLowBattery.BATTERY_LEVEL_LOW
                : this.api.hap.Characteristic.StatusLowBattery.BATTERY_LEVEL_NORMAL;
        this.api = api;
        this.debug = !!config.debug;
        this.log = !this.debug
            ? log
            : Object.assign(log, {
                debug: (message, ...parameters) => {
                    log.info(`DEBUG: ${message}`, ...parameters);
                },
            });
        this.name = config.name;
        this.model = config.model;
        this.serialnum = config.serialnum;
        this.blid = config.blid;
        this.robotpwd = config.robotpwd;
        this.ipaddress = config.ipaddress;
        this.firmware = "N/A";
        this.stopBehaviour = config.stopBehaviour !== undefined ? config.stopBehaviour : "home";
        const showDockAsContactSensor = config.dockContactSensor === undefined ? true : config.dockContactSensor;
        const showRunningAsContactSensor = config.runningContactSensor;
        const showBinStatusAsContactSensor = config.binContactSensor;
        const showDockingAsContactSensor = config.dockingContactSensor;
        const showHomeSwitch = config.homeSwitch;
        const Service = api.hap.Service;
        this.accessoryInfo = new Service.AccessoryInformation();
        this.filterMaintenance = new Service.FilterMaintenance(this.name);
        this.switchService = new Service.Switch(this.name);
        this.switchService.setPrimaryService(true);
        this.batteryService = new Service.Battery(this.name);
        if (showDockAsContactSensor) {
            this.dockService = new Service.ContactSensor(this.name + " Dock", "docked");
        }
        if (showRunningAsContactSensor) {
            this.runningService = new Service.ContactSensor(this.name + " Running", "running");
        }
        if (showBinStatusAsContactSensor) {
            this.binService = new Service.ContactSensor(this.name + " Bin Full", "Full");
        }
        if (showDockingAsContactSensor) {
            this.dockingService = new Service.ContactSensor(this.name + " Docking", "docking");
        }
        if (showHomeSwitch) {
            this.homeService = new Service.Switch(this.name + " Home", "returning");
        }
        const Characteristic = this.api.hap.Characteristic;
        const version = require("../package.json").version;
        this.accessoryInfo.setCharacteristic(Characteristic.Manufacturer, "iRobot");
        this.accessoryInfo.setCharacteristic(Characteristic.SerialNumber, this.serialnum);
        this.accessoryInfo.setCharacteristic(Characteristic.Identify, true);
        this.accessoryInfo.setCharacteristic(Characteristic.Name, this.name);
        this.accessoryInfo.setCharacteristic(Characteristic.Model, this.model);
        this.accessoryInfo.setCharacteristic(Characteristic.FirmwareRevision, version);
        this.switchService
            .getCharacteristic(Characteristic.On)
            .on("set", this.setRunningState.bind(this))
            .on("get", this.createCharacteristicGetter("Running status", this.runningStatus));
        this.batteryService
            .getCharacteristic(Characteristic.BatteryLevel)
            .on("get", this.createCharacteristicGetter("Battery level", this.batteryLevelStatus));
        this.batteryService
            .getCharacteristic(Characteristic.ChargingState)
            .on("get", this.createCharacteristicGetter("Charging status", this.chargingStatus));
        this.batteryService
            .getCharacteristic(Characteristic.StatusLowBattery)
            .on("get", this.createCharacteristicGetter("Low Battery status", this.batteryStatus));
        this.filterMaintenance
            .getCharacteristic(Characteristic.FilterChangeIndication)
            .on("get", this.createCharacteristicGetter("Bin status", this.binStatus));
        if (this.dockService) {
            this.dockService
                .getCharacteristic(Characteristic.ContactSensorState)
                .on("get", this.createCharacteristicGetter("Dock status", this.dockedStatus));
        }
        if (this.runningService) {
            this.runningService
                .getCharacteristic(Characteristic.ContactSensorState)
                .on("get", this.createCharacteristicGetter("Running status", this.runningStatus));
        }
        if (this.binService) {
            this.binService
                .getCharacteristic(Characteristic.ContactSensorState)
                .on("get", this.createCharacteristicGetter("Bin status", this.binStatus));
        }
        if (this.dockingService) {
            this.dockingService
                .getCharacteristic(Characteristic.ContactSensorState)
                .on("get", this.createCharacteristicGetter("Docking status", this.dockingStatus));
        }
        if (this.homeService) {
            this.homeService
                .getCharacteristic(Characteristic.On)
                .on("set", this.setDockingState.bind(this))
                .on("get", this.createCharacteristicGetter("Returning Home", this.dockingStatus));
        }
        this.startLongWatch();
    }
    identify() {
        this.log.info("Identify requested");
        this.connect(async (error, roomba) => {
            if (error || !roomba) {
                return;
            }
            try {
                await roomba.find();
            }
            catch (error) {
                this.log.warn("Roomba failed to locate: %s", error.message);
            }
        });
    }
    getServices() {
        const services = [
            this.accessoryInfo,
            this.switchService,
            this.batteryService,
            this.filterMaintenance,
        ];
        if (this.dockService) {
            services.push(this.dockService);
        }
        if (this.runningService) {
            services.push(this.runningService);
        }
        if (this.binService) {
            services.push(this.binService);
        }
        if (this.dockingService) {
            services.push(this.dockingService);
        }
        if (this.homeService) {
            services.push(this.homeService);
        }
        return services;
    }
    refreshState() {
        const now = Date.now();
        if (now - this.lastRefreshState < REFRESH_STATE_COALESCE_MILLIS) {
            return false;
        }
        this.lastRefreshState = now;
        this.connect(async (error, roomba) => {
            if (error || !roomba) {
                this.log.warn("Failed to connect to Roomba to refresh state: %s", error ? error.message : "Unknown");
                return;
            }
            const startedWaitingForStatus = Date.now();
            /* Wait until we've received a state with all of the information we desire */
            return new Promise((resolve) => {
                let receivedState = undefined;
                const timeout = setTimeout(() => {
                    this.log.debug("Timeout waiting for full state from Roomba ({}ms). Last state received was: %s", Date.now() - startedWaitingForStatus, receivedState ? JSON.stringify(receivedState) : "<none>");
                    resolve();
                }, MAX_WAIT_FOR_STATUS_MILLIS);
                const updateState = (state) => {
                    receivedState = state;
                    if (this.receivedRobotStateIsComplete(state)) {
                        clearTimeout(timeout);
                        /* NB: the actual state is received and updated in the listener in connect() */
                        this.log.debug("Refreshed Roomba's state in %ims: %s", Date.now() - now, JSON.stringify(state));
                        roomba.off("state", updateState);
                        resolve();
                    }
                };
                roomba.on("state", updateState);
                const onClose = () => {
                    roomba.off("close", onClose);
                    resolve();
                };
                roomba.on("close", onClose);
                const onError = () => {
                    roomba.off("error", onError);
                    resolve();
                };
                roomba.on("error", onError);
            });
        });
        return true;
    }
    receivedRobotStateIsComplete(state) {
        return (state.batPct != undefined && state.bin !== undefined && state.cleanMissionStatus !== undefined);
    }
    receiveRobotState(state) {
        const parsed = this.parseState(state);
        this.mergeCachedStatus(parsed);
        return true;
    }
    async connect(callback) {
        const getRoomba = () => {
            if (this._currentlyConnectedRoomba) {
                this._currentlyConnectedRoombaRequests++;
                return this._currentlyConnectedRoomba;
            }
            const roomba = new dorita980_1.default.Local(this.blid, this.robotpwd, this.ipaddress);
            this._currentlyConnectedRoomba = roomba;
            this._currentlyConnectedRoombaRequests = 1;
            const onClose = () => {
                if (roomba === this._currentlyConnectedRoomba) {
                    this.log.debug("Connection close received");
                    this._currentlyConnectedRoomba = undefined;
                }
                roomba.off("close", onClose);
            };
            roomba.on("close", onClose);
            const onError = (error) => {
                if (roomba === this._currentlyConnectedRoomba) {
                    this.log.debug("Connection received error: %s", error.message);
                    this._currentlyConnectedRoomba = undefined;
                }
                else {
                    this.log.debug("Old connection received error: %s", error.message);
                }
                roomba.off("error", onError);
            };
            roomba.on("error", onError);
            roomba.on("state", (state) => {
                this.receiveRobotState(state);
            });
            return roomba;
        };
        const stopUsingRoomba = async (roomba) => {
            if (roomba !== this._currentlyConnectedRoomba) {
                this.log.warn("Releasing an unexpected Roomba instance");
                await roomba.end();
                return;
            }
            this._currentlyConnectedRoombaRequests--;
            if (this._currentlyConnectedRoombaRequests === 0) {
                this._currentlyConnectedRoomba = undefined;
                this.log.debug("Releasing Roomba instance");
                await roomba.end();
            }
            else {
                this.log.debug("Leaving Roomba instance with %i ongoing requests", this._currentlyConnectedRoombaRequests);
            }
        };
        const roomba = getRoomba();
        if (roomba.connected) {
            this.log.debug("Reusing connected Roomba");
            await callback(null, roomba);
            await stopUsingRoomba(roomba);
            return;
        }
        let timedOut = false;
        const startConnecting = Date.now();
        const timeout = setTimeout(async () => {
            timedOut = true;
            this.log.warn("Timed out after %ims trying to connect to Roomba", Date.now() - startConnecting);
            await stopUsingRoomba(roomba);
            await callback(new Error("Connect timed out"));
        }, CONNECT_TIMEOUT_MILLIS);
        this.log.debug("Connecting to Roomba (%i others waiting)...", this._currentlyConnectedRoombaRequests - 1);
        const onConnect = async () => {
            roomba.off("connect", onConnect);
            if (timedOut) {
                this.log.debug("Connection established to Roomba after timeout");
                return;
            }
            clearTimeout(timeout);
            this.log.debug("Connected to Roomba in %ims", Date.now() - startConnecting);
            await callback(null, roomba);
            await stopUsingRoomba(roomba);
        };
        roomba.on("connect", onConnect);
    }
    setRunningState(powerOn, callback) {
        if (powerOn) {
            this.log.info("Starting Roomba");
            this.connect(async (error, roomba) => {
                if (error || !roomba) {
                    callback(error || new Error("Unknown error"));
                    return;
                }
                try {
                    /* To start Roomba we signal both a clean and a resume, as if Roomba is paused in a clean cycle,
                       we need to instruct it to resume instead.
                     */
                    await roomba.clean();
                    await roomba.resume();
                    this.log.debug("Roomba is running");
                    callback();
                    /* Force a refresh of state so we pick up the new state quickly */
                    this.refreshState();
                    /* After sending an action to Roomba, we start watching to ensure HomeKit has up to date status */
                    this.startWatching();
                }
                catch (error) {
                    this.log.warn("Roomba failed: %s", error.message);
                    callback(error);
                }
            });
        }
        else {
            this.log.info("Stopping Roomba");
            this.connect(async (error, roomba) => {
                if (error || !roomba) {
                    callback(error || new Error("Unknown error"));
                    return;
                }
                try {
                    const response = await roomba.getRobotState(["cleanMissionStatus"]);
                    const state = this.parseState(response);
                    if (state.running) {
                        this.log.debug("Roomba is pausing");
                        await roomba.pause();
                        callback();
                        /* Force a refresh of state so we pick up the new state quickly */
                        this.refreshState();
                        if (this.stopBehaviour === "home") {
                            this.log.debug("Roomba paused, returning to Dock");
                            await this.dockWhenStopped(roomba, 3000);
                        }
                        else {
                            this.log.debug("Roomba is paused");
                        }
                    }
                    else if (state.docking) {
                        this.log.debug("Roomba is docking");
                        await roomba.pause();
                        callback();
                        /* Force a refresh of state so we pick up the new state quickly */
                        this.refreshState();
                        this.log.debug("Roomba paused");
                    }
                    else if (state.charging) {
                        this.log.debug("Roomba is already docked");
                        callback();
                    }
                    else {
                        this.log.debug("Roomba is not running");
                        callback();
                    }
                    this.startWatching();
                }
                catch (error) {
                    this.log.warn("Roomba failed: %s", error.message);
                    callback(error);
                }
            });
        }
    }
    setDockingState(docking, callback) {
        this.log.debug("Setting docking state to %s", JSON.stringify(docking));
        this.connect(async (error, roomba) => {
            if (error || !roomba) {
                callback(error || new Error("Unknown error"));
                return;
            }
            try {
                if (docking) {
                    await roomba.dock();
                    this.log.debug("Roomba is docking");
                }
                else {
                    await roomba.pause();
                    this.log.debug("Roomba is paused");
                }
                callback();
                /* Force a refresh of state so we pick up the new state quickly */
                this.refreshState();
                /* After sending an action to Roomba, we start watching to ensure HomeKit has up to date status */
                this.startWatching();
            }
            catch (error) {
                this.log.warn("Roomba failed: %s", error.message);
                callback(error);
            }
        });
    }
    async dockWhenStopped(roomba, pollingInterval) {
        try {
            const state = await roomba.getRobotState(["cleanMissionStatus"]);
            switch (state.cleanMissionStatus.phase) {
                case "stop":
                    this.log.debug("Roomba has stopped, issuing dock request");
                    await roomba.dock();
                    this.log.debug("Roomba docking");
                    /* Force a refresh of state so we pick up the new state quickly */
                    this.refreshState();
                    break;
                case "run":
                    this.log.debug("Roomba is still running. Will check again in %is", pollingInterval / 1000);
                    await delay(pollingInterval);
                    this.log.debug("Trying to dock again...");
                    await this.dockWhenStopped(roomba, pollingInterval);
                    break;
                default:
                    this.log.debug("Roomba is not running");
                    break;
            }
        }
        catch (error) {
            this.log.warn("Roomba failed to dock: %s", error.message);
        }
    }
    /**
     * Creates as a Characteristic getter function that derives the CharacteristicValue from Roomba's status.
     */
    createCharacteristicGetter(name, extractValue) {
        return (callback) => {
            const returnCachedStatus = (status) => {
                const value = extractValue(status);
                if (value === undefined) {
                    this.log.debug("%s: Returning no value (%ims old)", name, Date.now() - status.timestamp);
                    callback(NO_VALUE);
                }
                else {
                    this.log.debug("%s: Returning %s (%ims old)", name, String(value), Date.now() - status.timestamp);
                    callback(null, value);
                }
            };
            this.refreshState();
            this.startWatching();
            if (Date.now() - this.cachedStatus.timestamp < MAX_CACHED_STATUS_AGE_MILLIS) {
                returnCachedStatus(this.cachedStatus);
            }
            else {
                /* Wait a short period of time (not too long for Homebridge) for a value */
                setTimeout(() => {
                    if (Date.now() - this.cachedStatus.timestamp < MAX_CACHED_STATUS_AGE_MILLIS) {
                        returnCachedStatus(this.cachedStatus);
                    }
                    else {
                        this.log.debug("%s: Returning no value due to timeout", name);
                        callback(NO_VALUE);
                    }
                }, 500);
            }
        };
    }
    /**
     * Merge in changes to the cached status, and update our characteristics so the plugin
     * preemptively reports state back to Homebridge.
     */
    mergeCachedStatus(status) {
        this.setCachedStatus({
            ...this.cachedStatus,
            timestamp: Date.now(),
            ...status,
        });
        if (Object.keys(status).length > 1) {
            this.log.debug("Merged updated state %s => %s", JSON.stringify(status), JSON.stringify(this.cachedStatus));
        }
    }
    /**
     * Update the cached status and update our characteristics so the plugin preemptively
     * reports state back to Homebridge.
     */
    setCachedStatus(status) {
        this.cachedStatus = status;
        this.updateCharacteristics(status);
    }
    parseState(state) {
        const status = {
            timestamp: Date.now(),
        };
        if (state.batPct !== undefined) {
            status.batteryLevel = state.batPct;
        }
        if (state.bin !== undefined) {
            status.binFull = state.bin.full;
        }
        if (state.cleanMissionStatus !== undefined) {
            /* See https://www.openhab.org/addons/bindings/irobot/ for a list of phases */
            switch (state.cleanMissionStatus.phase) {
                case "run":
                    status.running = true;
                    status.charging = false;
                    status.docking = false;
                    break;
                case "charge":
                case "recharge":
                    status.running = false;
                    status.charging = true;
                    status.docking = false;
                    break;
                case "hmUsrDock":
                case "hmMidMsn":
                case "hmPostMsn":
                    status.running = false;
                    status.charging = false;
                    status.docking = true;
                    break;
                case "stop":
                case "stuck":
                    status.running = false;
                    status.charging = false;
                    status.docking = false;
                    break;
                default:
                    this.log.warn("Unsupported phase: %s", state.cleanMissionStatus.phase);
                    status.running = false;
                    status.charging = false;
                    status.docking = false;
                    break;
            }
        }
        return status;
    }
    updateCharacteristics(status) {
        // this.log.debug("Updating characteristics for status: %s", JSON.stringify(status));
        const updateCharacteristic = (service, characteristicId, extractValue) => {
            const value = extractValue(status);
            if (value !== undefined) {
                const previousValue = extractValue(this.lastUpdatedStatus);
                if (value !== previousValue) {
                    this.log.debug("Updating %s %s from %s to %s", service.displayName, service.getCharacteristic(characteristicId).displayName, String(previousValue), String(value));
                    service.updateCharacteristic(characteristicId, value);
                }
            }
        };
        const Characteristic = this.api.hap.Characteristic;
        updateCharacteristic(this.switchService, Characteristic.On, this.runningStatus);
        updateCharacteristic(this.batteryService, Characteristic.ChargingState, this.chargingStatus);
        updateCharacteristic(this.batteryService, Characteristic.BatteryLevel, this.batteryLevelStatus);
        updateCharacteristic(this.batteryService, Characteristic.StatusLowBattery, this.batteryStatus);
        updateCharacteristic(this.filterMaintenance, Characteristic.FilterChangeIndication, this.binStatus);
        if (this.dockService) {
            updateCharacteristic(this.dockService, Characteristic.ContactSensorState, this.dockedStatus);
        }
        if (this.runningService) {
            updateCharacteristic(this.runningService, Characteristic.ContactSensorState, this.runningStatus);
        }
        if (this.binService) {
            updateCharacteristic(this.binService, Characteristic.ContactSensorState, this.binStatus);
        }
        if (this.dockingService) {
            updateCharacteristic(this.dockingService, Characteristic.ContactSensorState, this.dockingStatus);
        }
        if (this.homeService) {
            updateCharacteristic(this.homeService, Characteristic.On, this.dockingStatus);
        }
        this.lastUpdatedStatus = {
            ...this.lastUpdatedStatus,
            ...status,
        };
    }
    /**
     * Start actively watching Roomba's status and reporting updates to HomeKit.
     * We start watching whenever an event occurs, so we update HomeKit promptly
     * when the status changes.
     */
    startWatching() {
        this.lastWatchingRequestTimestamp = Date.now();
        if (this.watching !== undefined) {
            return;
        }
        const checkStatus = () => {
            const timeSinceLastWatchingRequest = Date.now() - (this.lastWatchingRequestTimestamp || 0);
            if (timeSinceLastWatchingRequest > WATCH_IDLE_TIMEOUT_MILLIS) {
                this.log.debug("Stopped watching Roomba due to idle timeout");
                this.stopWatching();
                return;
            }
            this.log.debug("Watching Roomba's status (repeating in %is, idle timeout in %is)", WATCH_INTERVAL_MILLIS / 1000, (WATCH_IDLE_TIMEOUT_MILLIS - timeSinceLastWatchingRequest) / 1000);
            this.refreshState();
            this.watching = setTimeout(checkStatus, WATCH_INTERVAL_MILLIS);
        };
        this.watching = setTimeout(checkStatus, WATCH_INTERVAL_MILLIS);
    }
    stopWatching() {
        if (this.watching !== undefined) {
            clearTimeout(this.watching);
            this.watching = undefined;
        }
    }
    startLongWatch() {
        const checkStatus = () => {
            this.log.debug("Refreshing Roomba's status (repeating in %im)", LONG_WATCH_INTERVAL_MILLIS / 60000);
            this.refreshState();
            setTimeout(checkStatus, LONG_WATCH_INTERVAL_MILLIS);
        };
        checkStatus();
    }
}
exports.default = RoombaAccessory;
